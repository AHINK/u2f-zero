/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include <stdio.h>
#include "idle.h"
#include "bsp.h"
#include "descriptors.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
#define HID_KEYBOARD_IFC                  0
//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------
// uint8_t thebuf1[32];
SI_SEGMENT_VARIABLE(thebuf1[64], uint8_t, SI_SEG_XDATA);
uint8_t tmpBuffer;
extern bool readpacket;
//SI_SEGMENT_VARIABLE(thebuf1[32],
//		uint8_t,
//		SI_SEG_CODE);
//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void USBD_EnterHandler(void) {

}

void USBD_ExitHandler(void) {

}

void USBD_ResetCb(void) {
	printf("USBD_ResetCb\r\n");
}

void USBD_SofCb(uint16_t sofNr) {

}

void USBD_DeviceStateChangeCb(USBD_State_TypeDef oldState,
		USBD_State_TypeDef newState) {
	printf("USBD_DeviceStateChangeCb\r\n");
}

bool USBD_IsSelfPoweredCb(void) {
	printf("USBD_IsSelfPoweredCb\r\n");
	return false;
}




USB_Status_TypeDef USBD_SetupCmdCb(
		SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {
	USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;
	int i;






	if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
			&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
			&& (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)) {
		// A HID device must extend the standard GET_DESCRIPTOR command
		// with support for HID descriptors.

		switch (setup->bRequest) {
		case GET_DESCRIPTOR:
			if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 0: // Interface 0
					USBD_Write(EP0, ReportDescriptor0,
							EFM8_MIN(sizeof(ReportDescriptor0), setup->wLength),
							false);
					retVal = USB_STATUS_OK;
					break;

				default: // Unhandled Interface
					break;
				}
			} else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 0: // Interface 0
					USBD_Write(EP0, (&configDesc[18]),
							EFM8_MIN(USB_HID_DESCSIZE, setup->wLength), false);
					retVal = USB_STATUS_OK;
					break;

				default: // Unhandled Interface
					break;
				}
			}
			break;
		}
	}
	else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
	           && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)
	           && (setup->wIndex == HID_KEYBOARD_IFC))
	  {
	    // Implement the necessary HID class specific commands.
	    switch (setup->bRequest)
	    {
	      case USB_HID_SET_REPORT:
	    	  printf("output report\r\n");
	        break;

	      case USB_HID_GET_REPORT:
	    	  printf("input report\r\n");
	    	  if ( USBD_Read(EP1OUT, thebuf1, sizeof(thebuf1), true) != USB_STATUS_OK)
	    		  printf("ERROR not ready\n");

	        break;

	      case USB_HID_SET_IDLE:
	        if (((setup->wValue & 0xFF) == 0)             // Report ID
	            && (setup->wLength == 0)
	            && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
	        {
	        	printf("set idle\r\n");
	          idleTimerSet(setup->wValue >> 8);
	          retVal = USB_STATUS_OK;
	        }
	        else printf("unhandled USB_HID_SET_IDLE\r\n");
	        break;

	      case USB_HID_GET_IDLE:
	        if ((setup->wValue == 0)                      // Report ID
	            && (setup->wLength == 1)
	            && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
	        {
	        	printf("get idle\r\n");
	          tmpBuffer = idleGetRate();
	          USBD_Write(EP0, &tmpBuffer, 1, false);
	          retVal = USB_STATUS_OK;
	        }
	        else printf("unhandled USB_HID_GET_IDLE\r\n");
	        break;
	      default:
	    	  printf("unhandled setup->bRequest\r\n");
	    }
	  }
	  else
	  {
		  if (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_ENDPOINT)
			  printf("endpoint called!\n");
		  // printf("NOT HANDLED\r\n");
	  }

	return retVal;
}

//SI_SEGMENT_VARIABLE(testtx[],
//		uint8_t,
//		SI_SEG_CODE) =
// "\x00\xff\xff\xff\xff\x86\x00\x08\x08\x07\x06\x05\x04\x03\x02\x01\x00\x00\x00\x00\x00\x00\x00"
//		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
//		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
		uint16_t xferred, uint16_t remaining) {

	int i = 0;




	if (epAddr == EP1OUT)
	{
		printf("USBD_XferCompleteCb read 0x%x/0x%x \r\n", xferred, remaining);

		for (i=0; i < sizeof(thebuf1); i++)
		{
			uint16_t l = (uint8_t)thebuf1[i];
			printf("%x",l);

		}
		printf("\n");
		readpacket = 1;

	}
	return 0;
}


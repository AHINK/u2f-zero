C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE CALLBACK
OBJECT MODULE PLACED IN .\src/callback.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/u2f-firmware/src/callback.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) 
                    -INTVECTOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/u2f-firmware/inc/config;/home/pp/apps/u2f-zero/u2f-firmware/i
                    -nc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/home/pp/SimplicityStudio_v3/develope
                    -r/sdks/si8051/v3//Device/EFM8UB1;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc;/home/pp/Simp
                    -licityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_usb/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device
                    -/EFM8UB1/peripheral_driver/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_assert) PRINT(.\src/callb
                    -ack.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/callback.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include <stdio.h>
   8          
   9          #include "SI_EFM8UB1_Register_Enums.h"
  10          #include "efm8_usb.h"
  11          #include "descriptors.h"
  12          #include "idle.h"
  13          #include "bsp.h"
*** WARNING C318 IN LINE 13 OF /home/pp/apps/u2f-zero/u2f-firmware/src/callback.c: can't open file 'bsp.h'
  14          
  15          // ----------------------------------------------------------------------------
  16          // Constants
  17          // ----------------------------------------------------------------------------
  18          SI_SBIT(BSP_LED_G, SFR_P1, 4);
  19          SI_SBIT(BSP_LED_B, SFR_P1, 5);
  20          SI_SBIT(BSP_LED_R, SFR_P1, 6);
  21          
  22          #define numLock     BSP_LED_G
  23          #define capsLock    BSP_LED_R
  24          
  25          // Endpoint address of the HID keyboard IN endpoint
  26          #define KEYBOARD_IN_EP_ADDR   EP1IN
  27          
  28          // Interface number of the HID keyboard
  29          #define HID_KEYBOARD_IFC                  0
  30          
  31          // ----------------------------------------------------------------------------
  32          // Variables
  33          // ----------------------------------------------------------------------------
  34          uint8_t tmpBuffer;
  35          extern uint8_t keySeqNo;                // Current position in report table.
  36          extern bool keyPushed;                  // Current pushbutton status.
  37          
  38          typedef uint8_t KeyReport_TypeDef[8];
  39          
  40          // Empty report
  41          SI_SEGMENT_VARIABLE(noKeyReport, const KeyReport_TypeDef, SI_SEG_CODE) =
  42          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  43          
  44          // A sequence of keystroke input reports.
  45          SI_SEGMENT_VARIABLE(reportTable[], const KeyReport_TypeDef, SI_SEG_CODE) =
  46          {
  47            {0x02, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'H'
  48            {0x02, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'I'
C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 2   

  49            {0x02, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'D'
  50            {0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00},    // space
  51            {0x02, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'K'
  52            {0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'e'
  53            {0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'y'
  54            {0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'b'
  55            {0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'o'
  56            {0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'a'
  57            {0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'r'
  58            {0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00},    // 'd'
  59            {0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00},    // space
  60          };
  61          
  62          // ----------------------------------------------------------------------------
  63          // Functions
  64          // ----------------------------------------------------------------------------
  65          void USBD_EnterHandler(void)
  66          {
  67   1      
  68   1              // printf("USBD_EnterHandler\r\n");
  69   1      }
  70          
  71          void USBD_ExitHandler(void)
  72          {
  73   1              // printf("USBD_ExitHandler\r\n");
  74   1      }
  75          
  76          void USBD_ResetCb(void)
  77          {
  78   1              printf("USBD_ResetCb\r\n");
  79   1      }
  80          
  81          void USBD_SofCb(uint16_t sofNr)
  82          {
  83   1      
  84   1        static bool keyReleased = 0;
  85   1      
  86   1      
  87   1      
  88   1        UNREFERENCED_ARGUMENT(sofNr);
  89   1      
  90   1        idleTimerTick();
  91   1      
  92   1        // Check if the device should send a report
  93   1        if (isIdleTimerExpired() == true)
  94   1        {
  95   2          if (keyPushed == true)
  96   2          {
  97   3            keyPushed = 0;
  98   3            keyReleased = 1;
  99   3            USBD_Write(KEYBOARD_IN_EP_ADDR,
 100   3                       &reportTable[keySeqNo],
 101   3                       sizeof(KeyReport_TypeDef),
 102   3                       false);
 103   3      
 104   3            keySeqNo++;
 105   3            if (keySeqNo == (sizeof(reportTable) / sizeof(KeyReport_TypeDef)))
 106   3            {
 107   4              keySeqNo = 0;
 108   4            }
 109   3          }
 110   2          else if ((isIdleTimerIndefinite() == false) || (keyReleased == true))
 111   2          {
C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 3   

 112   3            keyReleased = 0;
 113   3            USBD_Write(KEYBOARD_IN_EP_ADDR,
 114   3                       &noKeyReport,
 115   3                       sizeof(KeyReport_TypeDef),
 116   3                       false);
 117   3          }
 118   2        }
 119   1      }
 120          
 121          void USBD_DeviceStateChangeCb(USBD_State_TypeDef oldState,
 122                                        USBD_State_TypeDef newState)
 123          {
 124   1        bool numLockSave, capsLockSave;
 125   1      
 126   1        printf("USBD_DeviceStateChangeCb\r\n");
 127   1      
 128   1        // If not configured or in suspend, disable the LED
 129   1        if (newState < USBD_STATE_SUSPENDED)
 130   1        {
 131   2          // Disable the LED
 132   2          numLockSave = 1;
 133   2          capsLockSave = 1;
 134   2          numLock = 1;
 135   2          capsLock = 1;
 136   2        }
 137   1        // Entering suspend mode, power internal and external blocks down
 138   1        else if (newState == USBD_STATE_SUSPENDED)
 139   1        {
 140   2          // Disable the LED's
 141   2          numLockSave = numLock;
 142   2          capsLockSave = capsLock;
 143   2          numLock = 1;
 144   2          capsLock = 1;
 145   2      
 146   2          // Abort any pending transfer
 147   2          USBD_AbortTransfer(KEYBOARD_IN_EP_ADDR);
 148   2        }
 149   1        else if (newState == USBD_STATE_CONFIGURED)
 150   1        {
 151   2          idleTimerSet(POLL_RATE);
 152   2        }
 153   1      
 154   1        // Exiting suspend mode, power internal and external blocks up
 155   1        if (oldState == USBD_STATE_SUSPENDED)
 156   1        {
 157   2          // Restore the LED's to their previous values
 158   2          numLock = numLockSave;
 159   2          capsLock = capsLockSave;
 160   2        }
 161   1      }
 162          
 163          bool USBD_IsSelfPoweredCb(void)
 164          {
 165   1        printf("USBD_IsSelfPoweredCb\r\n");
 166   1        return false;
 167   1      }
 168          
 169          USB_Status_TypeDef USBD_SetupCmdCb(SI_VARIABLE_SEGMENT_POINTER(
 172                                               setup,
 172                                               USB_Setup_TypeDef,
 172                                               MEM_MODEL_SEG))
 173          {
 174   1      
C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 4   

 175   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;
 176   1      
 177   1        printf("USBD_SetupCmdCb\r\n");
 178   1      
 179   1        if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
 180   1            && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
 181   1            && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE))
 182   1        {
 183   2          // A HID device must extend the standard GET_DESCRIPTOR command
 184   2          // with support for HID descriptors.
 185   2          switch (setup->bRequest)
 186   2          {
 187   3            case GET_DESCRIPTOR:
 188   3              if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR)
 189   3              {
 190   4                switch (setup->wIndex)
 191   4                {
 192   5                  case 0: // Interface 0
 193   5      
 194   5                    USBD_Write(EP0,
 195   5                               ReportDescriptor0,
 196   5                               EFM8_MIN(sizeof(ReportDescriptor0), setup->wLength),
 197   5                               false);
 198   5                    retVal = USB_STATUS_OK;
 199   5                    break;
 200   5      
 201   5                  default: // Unhandled Interface
 202   5                    break;
 203   5                }
 204   4              }
 205   3              else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR)
 206   3              {
 207   4                switch (setup->wIndex)
 208   4                {
 209   5                  case 0: // Interface 0
 210   5      
 211   5                    USBD_Write(EP0,
 212   5                               (&configDesc[18]),
 213   5                               EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 214   5                               false);
 215   5                    retVal = USB_STATUS_OK;
 216   5                    break;
 217   5      
 218   5                  default: // Unhandled Interface
 219   5                    break;
 220   5                }
 221   4              }
 222   3              break;
 223   3          }
 224   2        }
 225   1        else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
 226   1                 && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)
 227   1                 && (setup->wIndex == HID_KEYBOARD_IFC))
 228   1        {
 229   2          // Implement the necessary HID class specific commands.
 230   2          switch (setup->bRequest)
 231   2          {
 232   3            case USB_HID_SET_REPORT:
 233   3              if (((setup->wValue >> 8) == 2)               // Output report
 234   3                  && ((setup->wValue & 0xFF) == 0)          // Report ID
 235   3                  && (setup->wLength == 1)                  // Report length
 236   3                  && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 237   3              {
C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 5   

 238   4                USBD_Read(EP0, &tmpBuffer, 1, true);
 239   4                retVal = USB_STATUS_OK;
 240   4              }
 241   3              break;
 242   3      
 243   3            case USB_HID_GET_REPORT:
 244   3              if (((setup->wValue >> 8) == 1)               // Input report
 245   3                  && ((setup->wValue & 0xFF) == 0)          // Report ID
 246   3                  && (setup->wLength == 8)                  // Report length
 247   3                  && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
 248   3              {
 249   4                if (keyPushed)
 250   4                {
 251   5                  // Send a key pushed report
 252   5                  USBD_Write(EP0,
 253   5                             &reportTable[keySeqNo],
 254   5                             sizeof(KeyReport_TypeDef),
 255   5                             false);
 256   5                }
 257   4                else
 258   4                {
 259   5                  // Send an empty (key released) report
 260   5                  USBD_Write(EP0,
 261   5                             &noKeyReport,
 262   5                             sizeof(KeyReport_TypeDef),
 263   5                             false);
 264   5                }
 265   4                retVal = USB_STATUS_OK;
 266   4              }
 267   3              break;
 268   3      
 269   3            case USB_HID_SET_IDLE:
 270   3              if (((setup->wValue & 0xFF) == 0)             // Report ID
 271   3                  && (setup->wLength == 0)
 272   3                  && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 273   3              {
 274   4                idleTimerSet(setup->wValue >> 8);
 275   4                retVal = USB_STATUS_OK;
 276   4              }
 277   3              break;
 278   3      
 279   3            case USB_HID_GET_IDLE:
 280   3              if ((setup->wValue == 0)                      // Report ID
 281   3                  && (setup->wLength == 1)
 282   3                  && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
 283   3              {
 284   4                tmpBuffer = idleGetRate();
 285   4                USBD_Write(EP0, &tmpBuffer, 1, false);
 286   4                retVal = USB_STATUS_OK;
 287   4              }
 288   3              break;
 289   3          }
 290   2        }
 291   1      
 292   1        return retVal;
 293   1      }
 294          
 295          
 296          
 297          uint16_t USBD_XferCompleteCb(uint8_t epAddr,
 298                                       USB_Status_TypeDef status,
 299                                       uint16_t xferred,
 300                                       uint16_t remaining)
C51 COMPILER V9.53.0.0   CALLBACK                                                          01/21/2016 23:19:39 PAGE 6   

 301          {
 302   1        UNREFERENCED_ARGUMENT(xferred);
 303   1        UNREFERENCED_ARGUMENT(remaining);
 304   1      
 305   1        printf("USBD_XferCompleteCb\r\n");
 306   1      
 307   1        if (status == USB_STATUS_OK)
 308   1        {
 309   2          // The only output reported supported is the SetReport to enable
 310   2          // Num Key and Caps Lock LED's.
 311   2          if (epAddr == EP0)
 312   2          {
 313   3            numLock = !((bool) (tmpBuffer & 0x01));
 314   3            capsLock = !((bool) (tmpBuffer & 0x02));
 315   3          }
 316   2        }
 317   1      
 318   1        return 0;
 319   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    777    ----
   CONSTANT SIZE    =    217    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

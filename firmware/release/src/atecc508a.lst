C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE ATECC508A
OBJECT MODULE PLACED IN .\src/atecc508a.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/firmware/src/atecc508a.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SIZE) INTV
                    -ECTOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/firmware/inc/config;/home/pp/apps/u2f-zero/firmware/inc;/home/pp/
                    -apps/u2f-zero/firmware/tests;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/home/pp/Si
                    -mplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device
                    -/EFM8UB1/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_usb/inc;/home/pp/SimplicityStudio_v3/develo
                    -per/sdks/si8051/v3//Device/EFM8UB1/peripheral_driver/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8
                    -_assert) REGFILE(u2f-firmware.ORC) PRINT(.\src/atecc508a.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/atecc508a.
                    -OBJ)

line level    source

   1          /*
   2           * atecc508a.c
   3           *
   4           *  Created on: Feb 14, 2016
   5           *      Author: Conor
   6           */
   7          #include <endian.h>
   8          #include <stdint.h>
   9          #include "app.h"
  10          #include "atecc508a.h"
  11          #include "i2c.h"
  12          #include "eeprom.h"
  13          
  14          #include "bsp.h"
  15          
  16          
  17          
  18          int8_t atecc_send(uint8_t cmd, uint8_t p1, uint16_t p2,
  19                                                  uint8_t * buf, uint8_t len)
  20          {
  21   1              static data uint8_t params[6];
  22   1              params[0] = 0x3;
  23   1              params[1] = 7+len;
  24   1              params[2] = cmd;
  25   1              params[3] = p1;
  26   1              params[4] = ((uint8_t*)&p2)[1];
  27   1              params[5] = ((uint8_t* )&p2)[0];
  28   1      
  29   1              smb_init_crc();
  30   1              smb_set_ext_write(buf, len);
  31   1              smb_write( ATECC508A_ADDR, params, sizeof(params));
  32   1              if (SMB_WAS_NACKED())
  33   1              {
  34   2                      return -1;
  35   2              }
  36   1              return 0;
  37   1      }
  38          
  39          void atecc_idle()
  40          {
  41   1              static data uint8_t params = 0x2;
  42   1              smb_write( ATECC508A_ADDR, &params, sizeof(params));
  43   1      }
  44          
  45          void atecc_sleep()
  46          {
  47   1              static data uint8_t params = 0x1;
  48   1              smb_write( ATECC508A_ADDR, &params, sizeof(params));
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 2   

  49   1      }
  50          
  51          void atecc_wake()
  52          {
  53   1              static uint8_t params[] = {0,0};
  54   1              smb_write( ATECC508A_ADDR, params, sizeof(params));
  55   1      }
  56          
  57          #define PKT_CRC(buf, pkt_len) (htole16(*((uint16_t*)(buf+pkt_len-2))))
  58          
  59          int8_t atecc_recv(uint8_t * buf, uint8_t buflen, struct atecc_response* res)
  60          {
  61   1              uint8_t pkt_len;
  62   1              smb_init_crc();
  63   1              pkt_len = smb_read( ATECC508A_ADDR,buf,buflen);
  64   1              if (SMB_WAS_NACKED())
  65   1              {
  66   2                      return -1;
  67   2              }
  68   1      
  69   1              if (SMB_FLAGS & SMB_READ_TRUNC)
  70   1              {
  71   2                      set_app_error(ERROR_READ_TRUNCATED);
  72   2              }
  73   1      
  74   1              if (pkt_len <= buflen && pkt_len >= 4)
  75   1              {
  76   2                      if (PKT_CRC(buf,pkt_len) != SMB.crc)
  77   2                      {
  78   3                              goto fail;
  79   3                      }
  80   2              }
  81   1              else
  82   1              {
  83   2                      goto fail;
  84   2              }
  85   1      
  86   1              if (pkt_len == 4 && buf[1] != 0)
  87   1              {
  88   2                      set_app_error(buf[1]);
  89   2                      return -1;
  90   2              }
  91   1      
  92   1              if (res != NULL)
  93   1              {
  94   2                      res->len = pkt_len - 3;
  95   2                      res->buf = buf+1;
  96   2              }
  97   1              return pkt_len;
  98   1      
  99   1              fail:
 100   1              return -1;
 101   1      }
 102          
 103          static void delay_cmd(uint8_t cmd)
 104          {
 105   1              uint8_t d = 0;
 106   1              switch(cmd)
 107   1              {
 108   2                      case ATECC_CMD_SIGN:
 109   2                              d = 50;
 110   2                              break;
 111   2                      case ATECC_CMD_GENKEY:
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 3   

 112   2                              d = 100;
 113   2                              break;
 114   2                      case ATECC_CMD_LOCK:
 115   2                              d = 32;
 116   2                              break;
 117   2                      default:
 118   2                              d = 26;
 119   2                              break;
 120   2              }
 121   1              u2f_delay(d);
 122   1      }
 123          
 124          int8_t atecc_send_recv(uint8_t cmd, uint8_t p1, uint16_t p2,
 125                                                                  uint8_t* tx, uint8_t txlen, uint8_t * rx,
 126                                                                  uint8_t rxlen, struct atecc_response* res)
 127          {
 128   1              uint8_t errors = 0;
 129   1              atecc_wake();
 130   1              resend:
 131   1              while(atecc_send(cmd, p1, p2, tx, txlen) == -1)
 132   1              {
 133   2                      u2f_delay(10);
 134   2                      errors++;
 135   2                      if (errors > 8)
 136   2                      {
 137   3                              return -1;
 138   3                      }
 139   2              }
 140   1              while(atecc_recv(rx,rxlen, res) == -1)
 141   1              {
 142   2                      errors++;
 143   2                      if (errors > 5)
 144   2                      {
 145   3                              u2f_printb("fail recv ", 1,appdata.error);
 146   3                              return -1;
 147   3                      }
 148   2                      switch(appdata.error)
 149   2                      {
 150   3                              case ERROR_NOTHING:
 151   3                                      delay_cmd(cmd);
 152   3                                      break;
 153   3                              case ERROR_ATECC_EXECUTION:
 154   3                                      delay_cmd(cmd);
 155   3                              case ERROR_ATECC_PARSE:
 156   3                              case ERROR_ATECC_FAULT:
 157   3                              case ERROR_ATECC_WAKE:
 158   3                              case ERROR_ATECC_WATCHDOG:
 159   3                                      goto resend;
 160   3                                      break;
 161   3                              default:
 162   3                                      u2f_delay(10);
 163   3                                      break;
 164   3                      }
 165   2      
 166   2              }
 167   1              atecc_idle();
 168   1              return 0;
 169   1      }
 170          
 171          int8_t atecc_write_eeprom(uint8_t base, uint8_t offset, uint8_t* srcbuf, uint8_t len)
 172          {
 173   1              uint8_t buf[7];
 174   1              struct atecc_response res;
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 4   

 175   1      
 176   1              uint8_t * dstbuf = srcbuf;
 177   1              if (offset + len > 4)
 178   1                      return -1;
 179   1              if (len < 4)
 180   1              {
 181   2                      atecc_send_recv(ATECC_CMD_READ,
 182   2                                      ATECC_RW_CONFIG, base, NULL, 0,
 183   2                                      buf, sizeof(buf), &res);
 184   2      
 185   2                      dstbuf = res.buf;
 186   2                      memmove(res.buf + offset, srcbuf, len);
 187   2              }
 188   1      
 189   1              atecc_send_recv(ATECC_CMD_WRITE,
 190   1                              ATECC_RW_CONFIG, base, dstbuf, 4,
 191   1                              buf, sizeof(buf), &res);
 192   1      
 193   1              if (res.buf[0])
 194   1              {
 195   2                      set_app_error(-res.buf[0]);
 196   2                      return -1;
 197   2              }
 198   1              return 0;
 199   1      }
 200          
 201          #ifdef ATECC_SETUP_DEVICE
              
              static int is_locked(uint8_t * buf)
              {
                      struct atecc_response res;
                      atecc_send_recv(ATECC_CMD_READ,
                                                      ATECC_RW_CONFIG,87/4, NULL, 0,
                                                      buf, 36, &res);
                      dump_hex(res.buf, res.len);
                      if (res.buf[87 % 4] == 0)
                              return 1;
                      else
                              return 0;
              }
              
              
              static void dump_config(uint8_t* buf)
              {
                      uint8_t i,j;
                      uint16_t crc = 0;
                      struct atecc_response res;
                      for (i=0; i < 4; i++)
                      {
                              atecc_send_recv(ATECC_CMD_READ,
                                              ATECC_RW_CONFIG | ATECC_RW_EXT, i << 3, NULL, 0,
                                              buf, 40, &res);
                              for(j = 0; j < res.len; j++)
                              {
                                      crc = feed_crc(crc,res.buf[j]);
                              }
                              dump_hex(res.buf,res.len);
                      }
              
                      u2f_printx("config crc:", 1,reverse_bits(crc));
              }
              
              static void atecc_setup_config(uint8_t* buf)
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 5   

              {
                      struct atecc_response res;
                      uint8_t i;
              
                      struct atecc_slot_config sc;
                      struct atecc_key_config kc;
                      memset(&sc, 0, sizeof(struct atecc_slot_config));
                      memset(&kc, 0, sizeof(struct atecc_key_config));
                      sc.readkey = 3;
                      sc.secret = 1;
                      sc.writeconfig = 0xa;
              
                      // set up read/write permissions for keys
                      for (i = 0; i < 16; i++)
                      {
                              if ( atecc_write_eeprom(ATECC_EEPROM_SLOT(i), ATECC_EEPROM_SLOT_OFFSET(i), &sc, ATECC_EEPROM_SLOT_SIZE) 
             -!= 0)
                              {
                                      u2f_printb("1 atecc_write_eeprom failed ",1, i);
                              }
              
                      }
              
              
                      kc.private = 1;
                      kc.pubinfo = 1;
                      kc.keytype = 0x4;
                      kc.lockable = 0;
              
                      // set up config for keys
                      for (i = 0; i < 16; i++)
                      {
                              if (i==15)
                              {
                                      kc.lockable = 1;
                              }
                              if ( atecc_write_eeprom(ATECC_EEPROM_KEY(i), ATECC_EEPROM_KEY_OFFSET(i), &kc, ATECC_EEPROM_KEY_SIZE) != 
             -0)
                              {
                                      u2f_printb("3 atecc_write_eeprom failed " ,1,i);
                              }
              
                      }
              
                      dump_config(buf);
              }
              
              // write a message to the otp memory before locking
              static void atecc_write_otp(uint8_t * buf)
              {
                      code char msg[] = "conorpp's u2f token.\r\n\0\0\0\0";
                      int i;
                      for (i=0; i<sizeof(msg); i+=4)
                      {
                              atecc_send_recv(ATECC_CMD_WRITE,
                                              ATECC_RW_OTP, ATECC_EEPROM_B2A(i), msg+i, 4,
                                              buf, sizeof(buf), NULL);
                      }
              }
              
              void atecc_setup_init(uint8_t * buf)
              {
                      if (!is_locked(buf))
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 6   

                      {
                              u2f_prints("setting up config...\r\n");
                              atecc_setup_config(buf);
                      }
                      else
                      {
                              u2f_prints("already locked\r\n");
                      }
              }
              
              // buf should be at least 40 bytes
              void atecc_setup_device(struct config_msg * msg)
              {
                      struct atecc_response res;
                      struct config_msg usbres;
              
                      static uint16_t crc = 0;
                      uint8_t buf[40];
              
                      memset(&usbres, 0, sizeof(struct config_msg));
                      usbres.cmd = msg->cmd;
              
                      switch(msg->cmd)
                      {
                              case U2F_CONFIG_GET_SERIAL_NUM:
              
                                      u2f_prints("U2F_CONFIG_GET_SERIAL_NUM\r\n");
                                      atecc_send_recv(ATECC_CMD_READ,
                                                      ATECC_RW_CONFIG | ATECC_RW_EXT, 0, NULL, 0,
                                                      buf, 40, &res);
                                      memmove(usbres.buf+1, res.buf, 15);
                                      usbres.buf[0] = 15;
                                      break;
              
                              case U2F_CONFIG_IS_BUILD:
                                      u2f_prints("U2F_CONFIG_IS_BUILD\r\n");
                                      usbres.buf[0] = 1;
                                      break;
                              case U2F_CONFIG_IS_CONFIGURED:
                                      u2f_prints("U2F_CONFIG_IS_CONFIGURED\r\n");
                                      usbres.buf[0] = 1;
                                      break;
                              case U2F_CONFIG_LOCK:
                                      crc = *(uint16_t*)msg->buf;
                                      usbres.buf[0] = 1;
                                      u2f_printx("got crc: ",1,crc);
              
                                      if (!is_locked(buf))
                                      {
                                              if (atecc_send_recv(ATECC_CMD_LOCK,
                                                              ATECC_LOCK_CONFIG, crc, NULL, 0,
                                                              buf, sizeof(buf), NULL))
                                              {
                                                      u2f_prints("ATECC_CMD_LOCK failed\r\n");
                                                      return;
                                              }
                                      }
                                      else
                                      {
                                              u2f_prints("already locked\r\n");
                                      }
                                      break;
                              case U2F_CONFIG_GENKEY:
C51 COMPILER V9.53.0.0   ATECC508A                                                         03/29/2016 00:06:38 PAGE 7   

                                      u2f_prints("U2F_CONFIG_GENKEY\r\n");
              
                                      atecc_send_recv(ATECC_CMD_GENKEY,
                                                      ATECC_GENKEY_PRIVATE, U2F_ATTESTATION_KEY_SLOT, NULL, 0,
                                                      appdata.tmp, sizeof(appdata.tmp), &res);
              
                                      u2f_printb("key is bytes ",1,res.len);
              
                                      memmove((uint8_t*)&usbres, res.buf, 64);
              
                                      break;
                              default:
                                      u2f_printb("invalid command: ",1,msg->cmd);
                      }
              
                      usb_write((uint8_t*)&usbres, HID_PACKET_SIZE);
              
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    799    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =      2      52
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

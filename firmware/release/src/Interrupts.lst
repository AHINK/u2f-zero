C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/29/2016 00:06:38 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src/Interrupts.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/firmware/src/Interrupts.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SIZE) INT
                    -VECTOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/firmware/inc/config;/home/pp/apps/u2f-zero/firmware/inc;/home/pp
                    -/apps/u2f-zero/firmware/tests;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/home/pp/S
                    -implicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Devic
                    -e/EFM8UB1/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_usb/inc;/home/pp/SimplicityStudio_v3/devel
                    -oper/sdks/si8051/v3//Device/EFM8UB1/peripheral_driver/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm
                    -8_assert) REGFILE(u2f-firmware.ORC) PRINT(.\src/Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/Interrup
                    -ts.OBJ)

line level    source

   1          /*
   2           * i2c.c
   3           *
   4           *      Author: Conor
   5           */
   6          #include <SI_EFM8UB1_Register_Enums.h>
   7          #include <stdint.h>
   8          #include "app.h"
   9          #include "i2c.h"
  10          
  11          #include "bsp.h"
  12          
  13          uint32_t data _MS_ = 0;
  14          
  15          SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
  16          {
  17   1              TMR2CN0_TF2H = 0;
  18   1              ++_MS_;
  19   1      }
  20          
  21          #define SMB_STATUS_START                        0xE0
  22          #define SMB_STATUS_MTX                          0xC0
  23          #define SMB_STATUS_MRX                          0x80
  24          #define SMB_STATE_MASK                          0xF0
  25          
  26          
  27          #define SMB_TX_STATE_MASK (SMB_WRITE_EXT|SMB_WRITE)
  28          #define SMB_TX_EXT (SMB_WRITE|SMB_WRITE_EXT)
  29          #define SMB_TX (SMB_WRITE)
  30          
  31          struct smb_interrupt_interface SMB;
  32          data volatile uint8_t SMB_FLAGS;
  33          
  34          static void update_from_packet_length()
  35          {
  36   1              if (SMB.read_buf[0] <= SMB.read_len)
  37   1              {
  38   2                      SMB.read_len = SMB.read_buf[0];
  39   2              }
  40   1              else
  41   1              {
  42   2                      // truncated read
  43   2                      SMB_FLAGS |= SMB_READ_TRUNC;
  44   2              }
  45   1      }
  46          
  47          static void _feed_crc(uint8_t b)
  48          {
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/29/2016 00:06:38 PAGE 2   

  49   1              if (SMB_HAS_CRC())
  50   1              {
  51   2                      SMB.crc = feed_crc(SMB.crc,b);
  52   2              }
  53   1      }
  54          
  55          static void restart_bus()
  56          {
  57   1              SMB0CF &= ~0x80;
  58   1              SMB0CF |= 0x80;
  59   1              SMB0CN0_STA = 0;
  60   1              SMB0CN0_STO = 0;
  61   1              SMB0CN0_ACK = 0;
  62   1              SMB_BUSY_CLEAR();
  63   1              SMB.errors = 0;
  64   1      }
  65          
  66          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  67          {
  68   1              data uint8_t bus = SMB0CN0 & SMB_STATE_MASK;
  69   1              if (SMB0CN0_ARBLOST != 0)
  70   1              {
  71   2                      goto fail;
  72   2              }
  73   1      
  74   1              switch (bus)
  75   1              {
  76   2                      case SMB_STATUS_START:
  77   2                              SMB0DAT = SMB.addr | (SMB_FLAGS & SMB_READ);
  78   2                              SMB0CN0_STA = 0;
  79   2                              break;
  80   2      
  81   2                      case SMB_STATUS_MTX:
  82   2                              if (!SMB0CN0_ACK)
  83   2                              {
  84   3                                      // NACK
  85   3                                      // end transaction
  86   3                                      SMB0CN0_STO = 1;
  87   3                                      SMB_FLAGS |= SMB_RECV_NACK;
  88   3                                      SMB_BUSY_CLEAR();
  89   3                              }
  90   2                              else if (!SMB_WRITING())
  91   2                              {
  92   3                                      // do nothing and switch to receive mode
  93   3                              }
  94   2                              else if (SMB.write_offset < SMB.write_len)
  95   2                              {
  96   3                                      // start writing first buffer
  97   3                                      // dont crc first byte for atecc508a
  98   3                                      if (SMB.write_offset) _feed_crc(SMB.write_buf[SMB.write_offset]);
  99   3                                      SMB0DAT = SMB.write_buf[SMB.write_offset++];
 100   3      
 101   3                              }
 102   2                              else if(SMB_WRITING_EXT() && SMB.write_ext_offset < SMB.write_ext_len)
 103   2                              {
 104   3                                      // start writing second optional buffer
 105   3                                      _feed_crc(SMB.write_ext_buf[SMB.write_ext_offset]);
 106   3                                      SMB0DAT = SMB.write_ext_buf[SMB.write_ext_offset++];
 107   3                              }
 108   2                              else if (SMB_HAS_CRC())
 109   2                              {
 110   3                                      // write optional CRC
 111   3                                      switch(SMB.crc_offset++)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/29/2016 00:06:38 PAGE 3   

 112   3                                      {
 113   4                                              case 0:
 114   4                                                      SMB.crc = reverse_bits(SMB.crc);
 115   4                                                      SMB0DAT = (uint8_t)SMB.crc;
 116   4                                                      break;
 117   4                                              case 1:
 118   4                                                      SMB0DAT = (uint8_t)(SMB.crc>>8);
 119   4                                                      SMB_CRC_CLEAR();
 120   4                                                      break;
 121   4                                      }
 122   3                              }
 123   2                              else
 124   2                              {
 125   3                                      // end transaction
 126   3                                      SMB0CN0_STO = 1;
 127   3                                      SMB_BUSY_CLEAR();
 128   3                                      SMB.errors = 0;
 129   3                              }
 130   2      
 131   2      
 132   2                              break;
 133   2      
 134   2                      case SMB_STATUS_MRX:
 135   2                              // read in buffer
 136   2      
 137   2                              if (SMB.read_offset < SMB.read_len)
 138   2                              {
 139   3                                      SMB.read_buf[SMB.read_offset] = SMB0DAT;
 140   3      
 141   3                                      // update with length from packet
 142   3                                      // warning this is device specific to atecc508a
 143   3                                      if (SMB.read_offset == 0)
 144   3                                      {
 145   4                                              update_from_packet_length();
 146   4                                      }
 147   3      
 148   3                                      if ((SMB.read_offset < (SMB.read_len - 2)) && SMB_HAS_CRC())
 149   3                                      {
 150   4                                              SMB.crc = feed_crc(SMB.crc, SMB.read_buf[SMB.read_offset]);
 151   4                                      }
 152   3      
 153   3                                      SMB.read_offset++;
 154   3                                      SMB0CN0_ACK = 1;
 155   3                              }
 156   2                              else
 157   2                              {
 158   3                                      // end transaction
 159   3                                      if (SMB_HAS_CRC())
 160   3                                      {
 161   4                                              SMB.crc = reverse_bits(SMB.crc);
 162   4                                      }
 163   3                                      SMB_BUSY_CLEAR();
 164   3                                      SMB0CN0_ACK = 0;
 165   3                                      SMB0CN0_STO = 1;
 166   3                                      SMB.errors = 0;
 167   3                              }
 168   2      
 169   2                              break;
 170   2      
 171   2                      default:
 172   2                              goto fail;
 173   2                              break;
 174   2      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/29/2016 00:06:38 PAGE 4   

 175   2              }
 176   1      
 177   1      
 178   1              // interrupt flag
 179   1              SMB0CN0_SI = 0;
 180   1              return;
 181   1      
 182   1              fail:
 183   1                      u2f_printb("smbus fail ",1,bus);
 184   1                      restart_bus();
 185   1                      SMB0CN0_SI = 0;
 186   1      }
 187          
 188          //-----------------------------------------------------------------------------
 189          // TIMER3_ISR
 190          //-----------------------------------------------------------------------------
 191          //
 192          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 193          // TMR3CN::TF3H (Timer # High Byte Overflow Flag)
 194          // TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
 195          //
 196          //
 197          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 198          // The SMBus is disabled and re-enabled here
 199          //
 200          //-----------------------------------------------------------------------------
 201          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 202          {
 203   1              restart_bus();
 204   1      }
 205          
 206          
 207          
 208          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    584    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =     21    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

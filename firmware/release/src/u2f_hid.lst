C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE U2F_HID
OBJECT MODULE PLACED IN .\src/u2f_hid.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/firmware/src/u2f_hid.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SIZE) INTVEC
                    -TOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/firmware/inc/config;/home/pp/apps/u2f-zero/firmware/inc;/home/pp/ap
                    -ps/u2f-zero/firmware/tests;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/home/pp/Simp
                    -licityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/E
                    -FM8UB1/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_usb/inc;/home/pp/SimplicityStudio_v3/develope
                    -r/sdks/si8051/v3//Device/EFM8UB1/peripheral_driver/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_a
                    -ssert) REGFILE(u2f-firmware.ORC) PRINT(.\src/u2f_hid.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/u2f_hid.OBJ)

line level    source

   1          /*
   2           * u2f_hid.c
   3           *
   4           *  Created on: Jan 26, 2016
   5           *      Author: pp
   6           */
   7          #include "app.h"
   8          
   9          #include <stdint.h>
  10          #include <string.h>
  11          
  12          #include "bsp.h"
  13          #include "u2f_hid.h"
  14          #include "u2f.h"
  15          
  16          #ifndef U2F_HID_DISABLE
  17          
  18          #define CID_MAX (sizeof(CIDS)/sizeof(uint32_t))
  19          
  20          typedef enum
  21          {
  22                  HID_BUSY=0,
  23                  HID_READY,
  24          } HID_STATE;
  25          
  26          struct CID
  27          {
  28                  uint32_t cid;
  29                  uint32_t last_used;
  30          };
  31          
  32          static struct hid_layer_param
  33          {
  34                  HID_STATE state;
  35                  uint32_t current_cid;
  36                  uint8_t current_cmd;
  37          
  38                  uint32_t last_buffered;
  39                  uint16_t bytes_buffered;
  40                  uint16_t req_len;
  41          
  42                  // number of payload bytes written in response
  43                  uint16_t bytes_written;
  44          
  45          
  46          
  47                  // total length of response in bytes
  48                  uint16_t res_len;
  49          
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 2   

  50                  #define BUFFER_SIZE 200
  51                  uint8_t buffer[BUFFER_SIZE];
  52          
  53          
  54          } hid_layer;
  55          
  56          struct CID CIDS[5];
  57          static uint8_t CID_NUM = 0;
  58          
  59          static uint8_t _hid_pkt[HID_PACKET_SIZE];
  60          static uint8_t _hid_offset = 0;
  61          static uint8_t _hid_seq = 0;
  62          static uint8_t _hid_in_session = 0;
  63          
  64          #define u2f_hid_busy() (_hid_in_session)
  65          
  66          #define MIN(a,b) ((a) < (b) ? (a):(b))
  67          
  68          void u2f_hid_init()
  69          {
  70   1              memset(CIDS, 0, sizeof(CIDS));
  71   1              memset(&hid_layer, 0, sizeof(hid_layer));
  72   1              CID_NUM = 0;
  73   1              _hid_offset = 0;
  74   1              _hid_seq = 0;
  75   1              _hid_in_session = 0;
  76   1      }
  77          
  78          void u2f_hid_set_len(uint16_t len)
  79          {
  80   1              hid_layer.res_len = len;
  81   1      }
  82          
  83          
  84          static void u2f_hid_reset_packet()
  85          {
  86   1              _hid_seq = 0;
  87   1              _hid_offset = 0;
  88   1              _hid_in_session = 0;
  89   1              memset(&hid_layer, 0, sizeof(hid_layer));
  90   1              memset(_hid_pkt, 0, HID_PACKET_SIZE);
  91   1      }
  92          
  93          // writes what has been buffered and clears memory
  94          void u2f_hid_flush()
  95          {
  96   1              if (_hid_offset)
  97   1              {
  98   2                      usb_write(_hid_pkt, HID_PACKET_SIZE);
  99   2              }
 100   1              u2f_hid_reset_packet();
 101   1      }
 102          
 103          
 104          void u2f_hid_writeback(uint8_t * payload, uint16_t len)
 105          {
 106   1              struct u2f_hid_msg * r = (struct u2f_hid_response *) _hid_pkt;
 107   1              _hid_in_session = 1;
 108   1              if (_hid_offset == 0)
 109   1              {
 110   2                      r->cid = hid_layer.current_cid;
 111   2                      if (!_hid_seq)
 112   2                      {
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 3   

 113   3                              r->pkt.init.cmd = hid_layer.current_cmd;
 114   3                              U2FHID_SET_LEN(r, hid_layer.res_len);
 115   3                              _hid_offset = 7;
 116   3                      }
 117   2                      else
 118   2                      {
 119   3                              r->pkt.cont.seq = _hid_seq - 1;
 120   3                              _hid_offset = 5;
 121   3                              if (_hid_seq-1 > 127)
 122   3                              {
 123   4                                      set_app_error(ERROR_SEQ_EXCEEDED);
 124   4                                      return;
 125   4                              }
 126   3                      }
 127   2              }
 128   1              while(len--)
 129   1              {
 130   2                      _hid_pkt[_hid_offset++] = *payload++;
 131   2                      hid_layer.bytes_written++;
 132   2                      if (_hid_offset == HID_PACKET_SIZE)
 133   2                      {
 134   3                              _hid_offset = 0;
 135   3                              _hid_seq++;
 136   3      
 137   3                              usb_write(_hid_pkt, HID_PACKET_SIZE);
 138   3                              memset(_hid_pkt, 0, HID_PACKET_SIZE);
 139   3      
 140   3                              if (len)
 141   3                              {
 142   4                                      u2f_hid_writeback(payload, len);
 143   4                                      return;
 144   4                              }
 145   3                              else break;
 146   3                      }
 147   2              }
 148   1      
 149   1      }
 150          
 151          static uint8_t is_cid_free(struct CID* c)
 152          {
 153   1              return (c->cid == 0 || get_ms() - c->last_used > 1000);
 154   1      }
 155          
 156          static void refresh_cid(struct CID* c)
 157          {
 158   1              c->last_used = get_ms();
 159   1      }
 160          
 161          
 162          static uint32_t get_new_cid()
 163          {
 164   1              static uint32_t base = 0xcafebabe;
 165   1              int i;
 166   1              for(i = 0; i < CID_MAX; i++)
 167   1              {
 168   2                      if (is_cid_free(CIDS+i))
 169   2                      {
 170   3                              goto newcid;
 171   3                      }
 172   2              }
 173   1              return 0;
 174   1              newcid:
 175   1      
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 4   

 176   1              do
 177   1              {
 178   2                      CIDS[i].cid = base + CID_NUM++;
 179   2              }while(CIDS[i].cid == 0 || CIDS[i].cid == U2FHID_BROADCAST);
 180   1      
 181   1              refresh_cid(CIDS+i);
 182   1      
 183   1              return CIDS[i].cid;
 184   1      }
 185          
 186          static struct CID* get_cid(uint32_t cid)
 187          {
 188   1              uint8_t i;
 189   1              for(i = 0; i < CID_MAX; i++)
 190   1              {
 191   2                      if (CIDS[i].cid == cid)
 192   2                      {
 193   3                              return CIDS+i;
 194   3                      }
 195   2              }
 196   1              return NULL;
 197   1      }
 198          static void del_cid(uint32_t cid)
 199          {
 200   1              uint8_t i;
 201   1              for(i = 0; i < CID_MAX; i++)
 202   1              {
 203   2                      if (CIDS[i].cid == cid)
 204   2                      {
 205   3                              CIDS[i].cid = 0;
 206   3                      }
 207   2              }
 208   1      }
 209          
 210          static int check_cid(uint32_t cid)
 211          {
 212   1              return (get_cid(cid) != NULL);
 213   1      }
 214          
 215          static void stamp_error(uint32_t cid, uint8_t err)
 216          {
 217   1              struct u2f_hid_msg * res = (struct u2f_hid_msg *)_hid_pkt;
 218   1              res->cid = cid;
 219   1              res->pkt.init.cmd = U2FHID_ERROR;
 220   1              res->pkt.init.payload[0] = err;
 221   1              res->pkt.init.bcnth = 0;
 222   1              res->pkt.init.bcntl = 1;
 223   1              // TODO this is tramping on potential other response data
 224   1              usb_write(_hid_pkt, HID_PACKET_SIZE);
 225   1              del_cid(cid);
 226   1      }
 227          
 228          // TODO double check if this is really needed
 229          static void start_buffering(struct u2f_hid_msg* req)
 230          {
 231   1              _hid_in_session = 1;
 232   1              hid_layer.bytes_buffered = U2FHID_INIT_PAYLOAD_SIZE;
 233   1              hid_layer.req_len = U2FHID_LEN(req);
 234   1              memmove(hid_layer.buffer, req->pkt.init.payload, U2FHID_INIT_PAYLOAD_SIZE);
 235   1      }
 236          
 237          static int buffer_request(struct u2f_hid_msg* req)
 238          {
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 5   

 239   1              if (hid_layer.bytes_buffered + U2FHID_CONT_PAYLOAD_SIZE > BUFFER_SIZE)
 240   1              {
 241   2                      u2f_prints("buffer full\r\n");
 242   2                      stamp_error(req->cid, ERR_OTHER);
 243   2                      return -1;
 244   2              }
 245   1              memmove(hid_layer.buffer + hid_layer.bytes_buffered, req->pkt.cont.payload, U2FHID_CONT_PAYLOAD_SIZE);
 246   1              hid_layer.bytes_buffered += U2FHID_CONT_PAYLOAD_SIZE;
 247   1      }
 248          
 249          static void hid_u2f_parse(struct u2f_hid_msg* req)
 250          {
 251   1      
 252   1              uint16_t len = 0;
 253   1              struct u2f_hid_init_response * init_res = appdata.tmp;
 254   1      
 255   1              switch(hid_layer.current_cmd)
 256   1              {
 257   2                      case U2FHID_INIT:
 258   2                              //u2f_printlx("got init packet ",1,req->cid);
 259   2                              if (U2FHID_LEN(req) != 8)
 260   2                              {
 261   3                                      // this one is safe
 262   3                                      stamp_error(hid_layer.current_cid, ERR_INVALID_LEN);
 263   3                                      u2f_prints("invalid len init\r\n");
 264   3                                      goto fail;
 265   3                              }
 266   2                              u2f_hid_set_len(17);
 267   2      
 268   2                              //u2f_printlx("cid: ",1,hid_layer.current_cid);
 269   2                              if (hid_layer.current_cid == 0)
 270   2                              {
 271   3                                      u2f_prints("out of cid's\r\n");
 272   3                                      goto fail;
 273   3                              }
 274   2      
 275   2                              init_res->cid = get_new_cid();
 276   2                              init_res->version_id = 1;
 277   2                              init_res->version_major = 1;
 278   2                              init_res->version_minor = 0;
 279   2                              init_res->version_build = 0;
 280   2                              init_res->cflags = 0;
 281   2      
 282   2                              // write back the same data nonce
 283   2                              u2f_hid_writeback(req->pkt.init.payload, 8);
 284   2                              u2f_hid_writeback(init_res, 9);
*** WARNING C182 IN LINE 284 OF /home/pp/apps/u2f-zero/firmware/src/u2f_hid.c: pointer to different objects
 285   2                              u2f_hid_flush();
 286   2                              hid_layer.current_cid = init_res->cid;
 287   2      
 288   2                              break;
 289   2                      case U2FHID_MSG:
 290   2      
 291   2                              if (U2FHID_LEN(req) < 4)
 292   2                              {
 293   3                                      // TODO bad
 294   3                                      stamp_error(hid_layer.current_cid, ERR_INVALID_LEN);
 295   3                                      u2f_prints("invalid len msg\r\n");
 296   3                                      goto fail;
 297   3                              }
 298   2                              //u2f_prints("U2FHID_MSG\r\n");
 299   2                              // buffer 2 payloads (120 bytes) to get full U2F message
 300   2                              // assuming key handle is < 45 bytes
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 6   

 301   2                              //              7 bytes for apdu header
 302   2                              //              7 + 66 bytes + key handle for authenticate message
 303   2                              //      7 + 64 for register message
 304   2                              if (hid_layer.bytes_buffered == 0)
 305   2                              {
 306   3                                      start_buffering(req);
 307   3                                      if (hid_layer.bytes_buffered >= U2FHID_LEN(req))
 308   3                                      {
 309   4                                              u2f_request((struct u2f_request_apdu *)hid_layer.buffer);
 310   4                                      }
 311   3                              }
 312   2                              else
 313   2                              {
 314   3                                      buffer_request(req);
 315   3                                      if (hid_layer.bytes_buffered >= hid_layer.req_len)
 316   3                                      {
 317   4                                              u2f_request((struct u2f_request_apdu *)hid_layer.buffer);
 318   4                                      }
 319   3                              }
 320   2      
 321   2      
 322   2                              break;
 323   2                      case U2FHID_PING:
 324   2      
 325   2                              //u2f_prints("U2F PING\r\n");
 326   2      
 327   2                              if (!u2f_hid_busy())
 328   2                              {
 329   3                                      u2f_hid_set_len(U2FHID_LEN(req));
 330   3                                      u2f_hid_writeback(req->pkt.init.payload, MIN(hid_layer.res_len, U2FHID_INIT_PAYLOAD_SIZE));
 331   3                              }
 332   2                              else
 333   2                              {
 334   3                                      u2f_hid_writeback(req->pkt.cont.payload, MIN(hid_layer.res_len - hid_layer.bytes_written, U2FHID_CONT_
             -PAYLOAD_SIZE));
 335   3                              }
 336   2      
 337   2                              if (hid_layer.res_len == hid_layer.bytes_written) u2f_hid_flush();
 338   2                              break;
 339   2      
 340   2                      case U2FHID_WINK:
 341   2                              //u2f_prints("U2F WINK\r\n");
 342   2                              if (U2FHID_LEN(req) != 0)
 343   2                              {
 344   3                                      // this one is safe
 345   3                                      stamp_error(hid_layer.current_cid, ERR_INVALID_LEN);
 346   3                                      u2f_prints("invalid len wink but who cares\r\n");
 347   3                              }
 348   2                              u2f_hid_set_len(0);
 349   2                              u2f_hid_writeback(NULL, 0);
 350   2                              u2f_hid_flush();
 351   2                              appdata.state = APP_WINK;
 352   2                              break;
 353   2                      case U2FHID_LOCK:
 354   2                              // TODO
 355   2                              //u2f_prints("U2F LOCK\r\n");
 356   2                              break;
 357   2                      default:
 358   2                              u2f_printb("invalid cmd: ", hid_layer.current_cmd);
 359   2                              stamp_error(hid_layer.current_cid, ERR_INVALID_CMD);
 360   2                              goto fail;
 361   2              }
 362   1      
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 7   

 363   1              return;
 364   1      
 365   1              fail:
 366   1                      u2f_prints("U2F HID FAIL\r\n");
 367   1              return;
 368   1      }
 369          
 370          
 371          void u2f_hid_request(struct u2f_hid_msg* req)
 372          {
 373   1              uint8_t* payload = req->pkt.init.payload;
 374   1              struct CID* cid = get_cid(req->cid);
 375   1      
 376   1      
 377   1              if (cid != NULL)
 378   1              {
 379   2                      refresh_cid(cid);
 380   2              }
 381   1              else if (req->cid == U2FHID_BROADCAST)
 382   1              {
 383   2      
 384   2              }
 385   1              else
 386   1              {
 387   2                      // Ignore CID's we did not allocate.
 388   2                      //u2f_printlx("ignoring pkt ",1,req->cid);
 389   2                      return;
 390   2              }
 391   1      
 392   1              hid_layer.state = (u2f_hid_busy()) ? HID_BUSY : HID_READY;
 393   1      
 394   1              switch(hid_layer.state)
 395   1              {
 396   2                      case HID_READY:
 397   2                              if (req->pkt.init.cmd & TYPE_INIT)
 398   2                              {
 399   3                                      if (U2FHID_LEN(req) > U2FHID_MAX_PAYLOAD_SIZE)
 400   3                                      {
 401   4                                              //u2f_prints("length too big\r\n");
 402   4                                              stamp_error(req->cid, ERR_INVALID_LEN);
 403   4                                              return;
 404   4                                      }
 405   3                                      u2f_hid_reset_packet();
 406   3                                      hid_layer.current_cid = req->cid;
 407   3                                      hid_layer.current_cmd = req->pkt.init.cmd;
 408   3                                      hid_layer.last_buffered = get_ms();
 409   3      
 410   3      
 411   3                              }
 412   2                              else
 413   2                              {
 414   3                                      stamp_error(req->cid, ERR_INVALID_CMD);
 415   3                                      u2f_prints("ERR_INVALID_CMD\r\n");
 416   3                                      return;
 417   3                              }
 418   2      
 419   2                              break;
 420   2                      case HID_BUSY:
 421   2                              // buffer long requests
 422   2                              if (req->cid == hid_layer.current_cid)
 423   2                              {
 424   3                                      if (req->pkt.init.cmd & TYPE_INIT)
 425   3                                      {
C51 COMPILER V9.53.0.0   U2F_HID                                                           03/29/2016 00:06:40 PAGE 8   

 426   4                                              // TODO
 427   4                                              //u2f_prints("this should resync but im lazy\r\n");
 428   4                                      }
 429   3                                      hid_layer.last_buffered = get_ms();
 430   3                                      // TODO verify packets arrive in ascending order
 431   3      
 432   3                              }
 433   2                              else if (U2FHID_TIMEOUT(&hid_layer))
 434   2                              {
 435   3                                      // return timeout error for old channel and run again for new channel
 436   3                                      //u2f_prints("timeout, switching\r\n");
 437   3                                      hid_layer.state = HID_READY;
 438   3                                      u2f_hid_reset_packet();
 439   3                                      stamp_error(hid_layer.current_cid, ERR_MSG_TIMEOUT);
 440   3                                      u2f_hid_request(req);
 441   3                                      return;
 442   3                              }
 443   2                              else
 444   2                              {
 445   3                                      // Current application may not be interrupted
 446   3                                      // TODO this will be bad
 447   3                                      stamp_error(req->cid, ERR_CHANNEL_BUSY);
 448   3                                      //u2f_printlx("ERR_CHANNEL_BUSY ", 2, req->cid, hid_layer.current_cid);
 449   3                                      return;
 450   3                              }
 451   2                              break;
 452   2      
 453   2              }
 454   1      
 455   1              hid_u2f_parse(req);
 456   1      
 457   1      
 458   1              return;
 459   1      }
 460          
 461          #endif
*** WARNING C291 IN LINE 247 OF /home/pp/apps/u2f-zero/firmware/src/u2f_hid.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1860    ----
   CONSTANT SIZE    =    146    ----
   XDATA SIZE       =    330      45
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.53.0.0   U2F_ATECC                                                         03/28/2016 20:18:26 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE U2F_ATECC
OBJECT MODULE PLACED IN .\src/u2f-atecc.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/firmware/src/u2f-atecc.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SIZE) INTV
                    -ECTOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/firmware/inc/config;/home/pp/apps/u2f-zero/firmware/inc;/home/pp/
                    -apps/u2f-zero/firmware/tinyprintf;/home/pp/apps/u2f-zero/firmware/tests;/home/pp/SimplicityStudio_v3/developer/sdks/si80
                    -51/v3//Device/shared/si8051Base;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1;/home/pp/Simplicit
                    -yStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_
                    -usb/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1/peripheral_driver/inc;/home/pp/SimplicityS
                    -tudio_v3/developer/sdks/si8051/v3//Lib/efm8_assert) REGFILE(u2f-firmware.ORC) PRINT(.\src/u2f-atecc.lst) COND PAGEWIDTH(
                    -120) PAGELENGTH(65) OBJECT(.\src/u2f-atecc.OBJ)

line level    source

   1          /*
   2           * u2f-atecc.c
   3           *
   4           *  Created on: Feb 27, 2016
   5           *      Author: pp
   6           */
   7          
   8          #include "app.h"
   9          #ifndef U2F_DISABLE
  10          #include "bsp.h"
  11          #include "u2f.h"
  12          #include "u2f_hid.h"
  13          #include "eeprom.h"
  14          #include "atecc508a.h"
  15          
  16          
  17          
  18          struct key_handle
  19          {
  20                  uint8_t index;
  21                  uint8_t entropy[3];
  22          };
  23          
  24          struct key_storage_header
  25          {
  26                  uint8_t num_keys;
  27                  uint16_t valid_keys;
  28                  uint8_t num_issued;
  29          } key_store;
  30          
  31          #define U2F_NUM_KEYS                    U2F_ATTESTATION_KEY_SLOT
  32          #define U2F_KEYS_ADDR                   (0xF800)
  33          #define U2F_KEY_ADDR(k)                 (U2F_KEYS_ADDR + ((k)*U2F_KEY_HANDLE_SIZE))
  34          
  35          
  36          #define IS_KEY_VALID(mask,key)  ((~mask) & (1<<key))
  37          
  38          static struct u2f_hid_msg res;
  39          static uint8_t* resbuf = (uint8_t*)&res;
  40          static uint8_t resseq = 0;
  41          
  42          static void flush_key_store()
  43          {
  44   1              eeprom_erase(U2F_EEPROM_CONFIG);
  45   1              eeprom_write(U2F_EEPROM_CONFIG, (uint8_t* )&key_store, sizeof(struct key_storage_header));
  46   1      }
  47          
  48          void u2f_init()
C51 COMPILER V9.53.0.0   U2F_ATECC                                                         03/28/2016 20:18:26 PAGE 2   

  49          {
  50   1              uint8_t i,j;
  51   1              struct atecc_response res;
  52   1      
  53   1              eeprom_read(U2F_EEPROM_CONFIG, (uint8_t* )&key_store, sizeof(struct key_storage_header));
  54   1      
  55   1              // initialize key handles
  56   1              if (key_store.num_keys != U2F_NUM_KEYS)
  57   1              {
  58   2                      u2f_prints("init key handles\r\n");
  59   2                      key_store.num_keys = U2F_NUM_KEYS;
  60   2                      key_store.valid_keys = 0;
  61   2                      key_store.num_issued = 0;
  62   2                      flush_key_store();
  63   2      
  64   2                      for (i=0; i < 2; i++)
  65   2                      {
  66   3                              atecc_send_recv(ATECC_CMD_RNG,ATECC_RNG_P1,ATECC_RNG_P2,
  67   3                                                              NULL, 0,
  68   3                                                              appdata.tmp,
  69   3                                                              sizeof(appdata.tmp), &res);
  70   3                              for (j=0; j < U2F_NUM_KEYS/2; j++) res.buf[j * U2F_KEY_HANDLE_SIZE] = j+1 + i*U2F_NUM_KEYS/2;
  71   3                              eeprom_write(U2F_KEYS_ADDR + i * (U2F_KEY_HANDLE_SIZE * U2F_NUM_KEYS/2),
  72   3                                                              res.buf, U2F_KEY_HANDLE_SIZE * U2F_NUM_KEYS/2);
  73   3                      }
  74   2      
  75   2              }
  76   1      }
  77          
  78          void u2f_response_writeback(uint8_t * buf, uint16_t len)
  79          {
  80   1              u2f_hid_writeback(buf, len);
  81   1      }
  82          
  83          void u2f_response_flush()
  84          {
  85   1              u2f_hid_flush();
  86   1      }
  87          
  88          void u2f_response_start()
  89          {
  90   1      }
  91          
  92          int8_t u2f_get_user_feedback()
  93          {
  94   1              return 0;
  95   1      }
  96          
  97          static uint8_t shabuf[70];
  98          static uint8_t shaoffset = 0;
  99          static struct atecc_response res_digest;
 100          
 101          void u2f_sha256_start()
 102          {
 103   1              shaoffset = 0;
 104   1              atecc_send_recv(ATECC_CMD_SHA,
 105   1                              ATECC_SHA_START, 0,NULL,0,
 106   1                              appdata.tmp, sizeof(appdata.tmp), NULL);
 107   1      }
 108          
 109          
 110          void u2f_sha256_update(uint8_t * buf, uint8_t len)
 111          {
C51 COMPILER V9.53.0.0   U2F_ATECC                                                         03/28/2016 20:18:26 PAGE 3   

 112   1              uint8_t i = 0;
 113   1              while(len--)
 114   1              {
 115   2                      shabuf[shaoffset++] = *buf++;
 116   2                      if (shaoffset == 64)
 117   2                      {
 118   3                              atecc_send_recv(ATECC_CMD_SHA,
 119   3                                              ATECC_SHA_UPDATE, 64,shabuf,64,
 120   3                                              appdata.tmp, sizeof(appdata.tmp), NULL);
 121   3                              shaoffset = 0;
 122   3                      }
 123   2              }
 124   1      }
 125          
 126          
 127          void u2f_sha256_finish()
 128          {
 129   1              atecc_send_recv(ATECC_CMD_SHA,
 130   1                              ATECC_SHA_END, shaoffset,shabuf,shaoffset,
 131   1                              shabuf, sizeof(shabuf), &res_digest);
 132   1      }
 133          
 134          
 135          int8_t u2f_ecdsa_sign(uint8_t * dest, uint8_t * handle)
 136          {
 137   1              struct atecc_response res;
 138   1              struct key_handle k;
 139   1              uint16_t keyslot = (uint16_t)((struct key_handle *)handle)->index;
 140   1              if (keyslot > U2F_NUM_KEYS)
 141   1              {
 142   2                      return -1;
 143   2              }
 144   1              if (keyslot == 0)
 145   1              {
 146   2                      keyslot = U2F_ATTESTATION_KEY_SLOT;
 147   2              }
 148   1              else
 149   1              {
 150   2                      keyslot--;
 151   2              }
 152   1      
 153   1              atecc_send_recv(ATECC_CMD_SIGN,
 154   1                              ATECC_SIGN_EXTERNAL, keyslot, NULL, 0,
 155   1                              appdata.tmp, sizeof(appdata.tmp), &res);
 156   1      
 157   1              if (keyslot != U2F_ATTESTATION_KEY_SLOT)
 158   1              {
 159   2                      eeprom_read(U2F_KEY_ADDR(keyslot), (uint8_t* )&k, U2F_KEY_HANDLE_SIZE);
 160   2      
 161   2                      if (
 162   2                                      ((struct key_handle *)handle)->index != k.index ||
 163   2                                      ((struct key_handle *)handle)->entropy[0] != k.entropy[0] ||
 164   2                                      ((struct key_handle *)handle)->entropy[1] != k.entropy[1] ||
 165   2                                      ((struct key_handle *)handle)->entropy[2] != k.entropy[2]
 166   2                      )
 167   2                      {
 168   3                              return -1;
 169   3                      }
 170   2              }
 171   1      
 172   1              memmove(dest, res.buf, 64);
 173   1      
 174   1              return 0;
C51 COMPILER V9.53.0.0   U2F_ATECC                                                         03/28/2016 20:18:26 PAGE 4   

 175   1      }
 176          
 177          // bad if this gets interrupted
 178          int8_t u2f_new_keypair(uint8_t * handle, uint8_t * pubkey)
 179          {
 180   1              struct atecc_response res;
 181   1              struct key_handle k;
 182   1              uint8_t keyslot = key_store.num_issued;
 183   1              if (keyslot > U2F_NUM_KEYS-1)
 184   1              {
 185   2                      return -1;
 186   2              }
 187   1      
 188   1              atecc_send_recv(ATECC_CMD_GENKEY,
 189   1                              ATECC_GENKEY_PRIVATE, keyslot, NULL, 0,
 190   1                              appdata.tmp, sizeof(appdata.tmp), &res);
 191   1      
 192   1              memmove(pubkey, res.buf, 64);
 193   1      
 194   1              eeprom_read(U2F_KEY_ADDR(keyslot), (uint8_t* )&k, U2F_KEY_HANDLE_SIZE);
 195   1              if (k.index-1 != keyslot)
 196   1              {
 197   2      
 198   2                      k.index = keyslot;
 199   2                      set_app_error(ERROR_BAD_KEY_STORE);
 200   2              }
 201   1              memmove(handle, &k, U2F_KEY_HANDLE_SIZE);
 202   1              key_store.num_issued++;
 203   1              flush_key_store();
 204   1      
 205   1              return 0;
 206   1      }
 207          
 208          int8_t u2f_load_key(uint8_t * handle, uint8_t len)
 209          {
 210   1              struct key_handle k;
 211   1              uint8_t keyslot = handle[0]-1;
 212   1              if (keyslot >= U2F_NUM_KEYS)
 213   1              {
 214   2                      return -1;
 215   2              }
 216   1              eeprom_read(U2F_KEY_ADDR(keyslot), (uint8_t* )&k, U2F_KEY_HANDLE_SIZE);
 217   1      
 218   1              if (
 219   1                              handle[0] != k.index ||
 220   1                              ((struct key_handle *)handle)->entropy[0] != k.entropy[0] ||
 221   1                              ((struct key_handle *)handle)->entropy[1] != k.entropy[1] ||
 222   1                              ((struct key_handle *)handle)->entropy[2] != k.entropy[2]
 223   1              )
 224   1              {
 225   2                      return -1;
 226   2              }
 227   1              return 0;
 228   1      }
*** WARNING C280 IN LINE 208 OF /home/pp/apps/u2f-zero/firmware/src/u2f-atecc.c: 'len': unreferenced local variable
 229          
 230          uint32_t u2f_count()
 231          {
 232   1              struct atecc_response res;
 233   1              atecc_send_recv(ATECC_CMD_COUNTER,
 234   1                              ATECC_COUNTER_INC, ATECC_COUNTER0,NULL,0,
 235   1                              appdata.tmp, sizeof(appdata.tmp), &res);
 236   1              return le32toh(*(uint32_t*)res.buf);
C51 COMPILER V9.53.0.0   U2F_ATECC                                                         03/28/2016 20:18:26 PAGE 5   

 237   1      }
 238          
 239          code char __attest[] =
 240          // {{{
 241          "\x30\x82\x01\x5a\x30\x82\x01\x00\x02\x01\x01\x30\x0a\x06\x08\x2a\x86\x48\xce\x3d"
 242          "\x04\x03\x02\x30\x39\x31\x0b\x30\x09\x06\x03\x55\x04\x06\x13\x02\x56\x41\x31\x14"
 243          "\x30\x12\x06\x03\x55\x04\x0a\x13\x0b\x43\x6f\x6e\x6f\x72\x43\x6f\x20\x4c\x4c\x43"
 244          "\x31\x14\x30\x12\x06\x03\x55\x04\x03\x13\x0b\x75\x32\x66\x7a\x65\x72\x6f\x2e\x63"
 245          "\x6f\x6d\x30\x1e\x17\x0d\x31\x36\x30\x33\x32\x39\x30\x30\x31\x37\x30\x35\x5a\x17"
 246          "\x0d\x32\x32\x30\x33\x32\x38\x30\x30\x31\x37\x30\x35\x5a\x30\x39\x31\x0b\x30\x09"
 247          "\x06\x03\x55\x04\x06\x13\x02\x56\x41\x31\x14\x30\x12\x06\x03\x55\x04\x0a\x13\x0b"
 248          "\x43\x6f\x6e\x6f\x72\x43\x6f\x20\x4c\x4c\x43\x31\x14\x30\x12\x06\x03\x55\x04\x03"
 249          "\x13\x0b\x75\x32\x66\x7a\x65\x72\x6f\x2e\x63\x6f\x6d\x30\x59\x30\x13\x06\x07\x2a"
 250          "\x86\x48\xce\x3d\x02\x01\x06\x08\x2a\x86\x48\xce\x3d\x03\x01\x07\x03\x42\x00\x04"
 251          "\x49\xc0\x88\x08\xf6\xff\xe0\x1f\xa3\xe0\x28\x28\xfb\x22\x1b\x20\xc0\xa4\xa3\x95"
 252          "\xba\xdc\xeb\xcf\xbd\x27\x45\xaa\xa5\x2f\x1f\x19\x6c\xfa\xe0\x0d\xdd\xc0\xef\x5d"
 253          "\x1e\xc1\x4d\x4b\x9a\x74\xb4\x30\x81\xfa\x93\x39\x0d\xc9\x35\xbd\xea\xce\x6a\x9b"
 254          "\x53\xa3\x3e\xbc\x30\x0a\x06\x08\x2a\x86\x48\xce\x3d\x04\x03\x02\x03\x48\x00\x30"
 255          "\x45\x02\x21\x00\xb4\xc1\xbc\x9c\x5c\x90\xab\xbf\x34\x29\x40\xf7\xe9\x4f\xb2\x4e"
 256          "\x74\x4b\x0a\x0d\x5c\x71\x0d\x7c\xd3\xa7\x9a\x13\x2d\xca\x2d\x10\x02\x20\x3f\x4c"
 257          "\x60\x70\x15\x2a\xc0\x1a\xc3\xad\xa3\x4b\x13\x24\x1c\x8d\x78\xa4\xcb\x34\xa7\xbc"
 258          "\x21\xe2\xdf\x20\x4f\xb1\x85\x92\xdc\x6a"
 259          
 260          // }}}
 261          ;
 262          uint8_t * u2f_get_attestation_cert()
 263          {
 264   1              return __attest;
 265   1      }
 266          
 267          
 268          uint16_t u2f_attestation_cert_size()
 269          {
 270   1              return sizeof(__attest)-1;
 271   1      }
 272          
 273          void set_response_length(uint16_t len)
 274          {
 275   1              u2f_hid_set_len(len);
 276   1      }
 277          
 278          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1082    ----
   CONSTANT SIZE    =    370    ----
   XDATA SIZE       =    147      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

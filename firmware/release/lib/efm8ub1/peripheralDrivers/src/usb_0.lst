C51 COMPILER V9.53.0.0   USB_0                                                             03/28/2016 20:17:26 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE USB_0
OBJECT MODULE PLACED IN .\lib/efm8ub1/peripheralDrivers/src/usb_0.OBJ
COMPILER INVOKED BY: Z:\home\pp\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /home/pp/apps/u2f-ze
                    -ro/firmware/lib/efm8ub1/peripheralDrivers/src/usb_0.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZ
                    -Y(3) OPTIMIZE(9,SIZE) INTVECTOR(0X0000) INTPROMOTE INCDIR(/home/pp/apps/u2f-zero/firmware/inc/config;/home/pp/apps/u2f-z
                    -ero/firmware/inc;/home/pp/apps/u2f-zero/firmware/tinyprintf;/home/pp/apps/u2f-zero/firmware/tests;/home/pp/SimplicityStu
                    -dio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/
                    -EFM8UB1;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc;/home/pp/SimplicityStudio_v3/developer
                    -/sdks/si8051/v3//Lib/efm8_usb/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/EFM8UB1/peripheral_drive
                    -r/inc;/home/pp/SimplicityStudio_v3/developer/sdks/si8051/v3//Lib/efm8_assert) REGFILE(u2f-firmware.ORC) PRINT(.\lib/efm8
                    -ub1/peripheralDrivers/src/usb_0.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\lib/efm8ub1/peripheralDrivers/src/usb_0
                    -.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "usb_0.h"
   8          #include <stdbool.h>
   9          #include <stdint.h>
  10          
  11          /** @addtogroup usb_0_runtime USB0 Runtime API */
  12          
  13          // -----------------------------------------------------------------------------
  14          // Functions
  15          
  16          // -------------------------------
  17          // Utility Functions
  18          
  19          /**************************************************************************//**
  20           * @brief       Reads a 16-bit indirect USB register value
  21           * @param       regAddr
  22           *   Address of high byte of 16-bit USB indirect register to read
  23           * @return      16-bit register value
  24           *****************************************************************************/
  25          static uint16_t USB_GetShortRegister(uint8_t regAddr)
  26          {
  27   1        uint16_t retVal;
  28   1      
  29   1        USB_READ_BYTE(regAddr);
  30   1        retVal = (USB0DAT << 8);
  31   1        USB_READ_BYTE((regAddr - 1));
  32   1        retVal |= USB0DAT;
  33   1      
  34   1        return retVal;
  35   1      }
  36          
  37          // -------------------------------
  38          // USB0 Peripheral Driver Functions
  39          
  40          void USB_SetIndex(uint8_t epsel)
  41          {
  42   1        USB_WRITE_BYTE(INDEX, epsel);
  43   1      }
  44          
  45          uint8_t USB_GetCommonInts(void)
  46          {
  47   1        USB_READ_BYTE(CMINT);
C51 COMPILER V9.53.0.0   USB_0                                                             03/28/2016 20:17:26 PAGE 2   

  48   1        return USB0DAT;
  49   1      }
  50          
  51          uint8_t USB_GetInInts(void)
  52          {
  53   1        USB_READ_BYTE(IN1INT);
  54   1        return USB0DAT;
  55   1      }
  56          
  57          uint8_t USB_GetOutInts(void)
  58          {
  59   1        USB_READ_BYTE(OUT1INT);
  60   1        return USB0DAT;
  61   1      }
  62          
  63          uint8_t USB_GetIndex(void)
  64          {
  65   1        USB_READ_BYTE(INDEX);
  66   1        return USB0DAT;
  67   1      }
  68          
  69          bool USB_IsSuspended(void)
  70          {
  71   1        USB_READ_BYTE(POWER);
  72   1        return USB0DAT & POWER_SUSMD__SUSPENDED;
  73   1      }
  74          
  75          bool USB_GetSetupEnd(void)
  76          {
  77   1        USB_READ_BYTE(E0CSR);
  78   1        return USB0DAT & E0CSR_SUEND__SET;
  79   1      }
  80          
  81          bool USB_Ep0SentStall(void)
  82          {
  83   1        USB_READ_BYTE(E0CSR);
  84   1        return USB0DAT & E0CSR_STSTL__SET;
  85   1      }
  86          
  87          bool USB_Ep0OutPacketReady(void)
  88          {
  89   1        USB_READ_BYTE(E0CSR);
  90   1        return USB0DAT & E0CSR_OPRDY__SET;
  91   1      }
  92          
  93          bool USB_Ep0InPacketReady(void)
  94          {
  95   1        USB_READ_BYTE(E0CSR);
  96   1        return USB0DAT & E0CSR_INPRDY__SET;
  97   1      }
  98          
  99          uint8_t USB_Ep0GetCount(void)
 100          {
 101   1        USB_READ_BYTE(E0CNT);
 102   1        return USB0DAT;
 103   1      }
 104          
 105          bool USB_EpnInGetSentStall(void)
 106          {
 107   1        USB_READ_BYTE(EINCSRL);
 108   1        return (bool)(USB0DAT & EINCSRL_STSTL__SET);
 109   1      }
 110          
C51 COMPILER V9.53.0.0   USB_0                                                             03/28/2016 20:17:26 PAGE 3   

 111          void USB_AbortInEp(uint8_t fifoNum)
 112          {
 113   1        USB_SetIndex(fifoNum);
 114   1        USB_EpnInFlush();
 115   1        USB_EpnInFlush();
 116   1      }
 117          
 118          bool USB_EpnOutGetSentStall(void)
 119          {
 120   1        USB_READ_BYTE(EOUTCSRL);
 121   1        return (bool)(USB0DAT & EOUTCSRL_STSTL__SET);
 122   1      }
 123          
 124          bool USB_EpnGetOutPacketReady(void)
 125          {
 126   1        USB_READ_BYTE(EOUTCSRL);
 127   1        return (bool)(USB0DAT & EOUTCSRL_OPRDY__SET);
 128   1      }
 129          
 130          uint16_t USB_EpOutGetCount(void)
 131          {
 132   1        return USB_GetShortRegister(EOUTCNTH);
 133   1      }
 134          
 135          void USB_AbortOutEp(uint8_t fifoNum)
 136          {
 137   1        USB_SetIndex(fifoNum);
 138   1        USB_EpnOutFlush();
 139   1        USB_EpnOutFlush();
 140   1      }
 141          
 142          void USB_ActivateEp(uint8_t ep,
 143                              uint16_t packetSize,
 144                              bool inDir,
 145                              bool splitMode,
 146                              bool isoMode)
 147          {
 148   1        uint8_t CSRH_mask = 0;
 149   1        uint16_t fifoSize;
 150   1      
 151   1        USB_SetIndex(ep);
 152   1      
 153   1        // Determine the available fifoSize for a given endpoint based on the
 154   1        // splitMode setting
 155   1        fifoSize = (splitMode == true) ? (16 << ep) : (32 << ep);
 156   1      
 157   1        if (packetSize <= fifoSize)
 158   1        {
 159   2          CSRH_mask |= EINCSRH_DBIEN__ENABLED;
 160   2        }
 161   1      
 162   1        if (isoMode == true)
 163   1        {
 164   2          CSRH_mask |= EINCSRH_ISO__ENABLED;
 165   2        }
 166   1      
 167   1        if (inDir == true)
 168   1        {
 169   2          CSRH_mask |= EINCSRH_DIRSEL__IN;
 170   2      
 171   2          if (splitMode == true)
 172   2          {
 173   3            CSRH_mask |= EINCSRH_SPLIT__ENABLED;
C51 COMPILER V9.53.0.0   USB_0                                                             03/28/2016 20:17:26 PAGE 4   

 174   3          }
 175   2          USB_WRITE_BYTE(EINCSRL, EINCSRL_CLRDT__BMASK);
 176   2          USB_WRITE_BYTE(EINCSRH, CSRH_mask);
 177   2        }
 178   1        else // OUT
 179   1        {
 180   2          USB_WRITE_BYTE(EOUTCSRL, EOUTCSRL_CLRDT__BMASK);
 181   2          USB_WRITE_BYTE(EOUTCSRH, CSRH_mask);
 182   2      
 183   2          if (splitMode == false)
 184   2          {
 185   3            USB_WRITE_BYTE(EINCSRH, 0);
 186   3          }
 187   2        }
 188   1      }
 189          
 190          uint16_t USB_GetSofNumber(void)
 191          {
 192   1        return USB_GetShortRegister(FRAMEH);
 193   1      }
 194          
 195          bool USB_GetIntsEnabled(void)
 196          {
 197   1        SFRPAGE = PG2_PAGE;
 198   1        return (bool)(EIE2 & EIE2_EUSB0__ENABLED);
 199   1      }
 200          
 201          bool USB_IsPrefetchEnabled(void)
 202          {
 203   1        SFRPAGE = PG2_PAGE;
 204   1        return (bool)(PFE0CN & PFE0CN_PFEN__ENABLED);
 205   1      }
 206          
 207          bool USB_IsRegulatorEnabled(void)
 208          {
 209   1        SFRPAGE = PG3_PAGE;
 210   1        return !(REG1CN & REG1CN_REG1ENB__DISABLED);
 211   1      }
 212          
 213          void USB_SuspendOscillator(void)
 214          {
 215   1        uint8_t clkSelSave = CLKSEL & 0x7F;
 216   1      
 217   1        CLKSEL = (CLKSEL_CLKDIV__SYSCLK_DIV_8 | CLKSEL_CLKSL__HFOSC0);
 218   1        SFRPAGE = LEGACY_PAGE;
 219   1        PCON1 |= PCON1_SUSPEND__SUSPEND;
 220   1        CLKSEL = clkSelSave;
 221   1      
 222   1        // If the target frequency is over 24MHz, our write to CLKSEL will be ignored.
 223   1        // If this is the case we need to do two writes: one to 24 MHz followed by the
 224   1        // actual value.
 225   1        if ((CLKSEL & 0x7F) != clkSelSave)
 226   1        {
 227   2          CLKSEL = (CLKSEL_CLKDIV__SYSCLK_DIV_1 | CLKSEL_CLKSL__HFOSC0);
 228   2          CLKSEL = clkSelSave;
 229   2        }
 230   1      }
 231          
 232          /**  @} (end addtogroup usb_0_runtime USB0 Runtime API) */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    511    ----
C51 COMPILER V9.53.0.0   USB_0                                                             03/28/2016 20:17:26 PAGE 5   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
